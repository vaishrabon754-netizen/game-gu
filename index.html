<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CURSED APARTMENT - BORO ROOM VERSION</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#000000">
<style>
    /* RESET AND BASE */
    * {
        margin: 0; 
        padding: 0; 
        box-sizing: border-box; 
        -webkit-touch-callout: none; 
        -webkit-user-select: none; 
        -moz-user-select: none; 
        -ms-user-select: none; 
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    body, html {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: 'Courier New', monospace;
        color: #e8d8c0;
        position: fixed;
    }
    
    /* CANVAS - VERY LARGE FOR BIG ROOMS */
    #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 4000px;
        height: 4000px;
        z-index: 1;
        display: block;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        transform-origin: 0 0;
    }
    
    /* SCREENS - ALWAYS FULLSCREEN */
    .screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: 15px;
        overflow: hidden;
    }
    
    #startScreen {
        display: flex;
        background: radial-gradient(ellipse at center, #111122 0%, #000000 100%);
    }
    
    #modeScreen {
        display: none;
        background: linear-gradient(135deg, #0a0a1a 0%, #000000 100%);
    }
    
    #gameScreen {
        display: none;
        background: transparent;
        pointer-events: none;
    }
    
    #winScreen, #gameoverScreen {
        display: none;
        background: radial-gradient(circle at center, rgba(20, 0, 20, 0.9), #000 70%);
    }
    
    /* SCREEN CONTENT */
    .screen h1 {
        font-size: 2.8rem;
        text-shadow: 0 0 25px #ff0040, 0 0 8px #800020;
        margin-bottom: 25px;
        text-align: center;
        letter-spacing: 3px;
        color: #ffd0d0;
        font-weight: normal;
        background: linear-gradient(45deg, #ffd0d0, #ff8080);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        position: relative;
    }
    
    .screen h1::after {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 180px;
        height: 3px;
        background: linear-gradient(90deg, transparent, #ff0040, transparent);
    }
    
    .btn {
        background: linear-gradient(145deg, #5a0000, #3a0000);
        color: #ffd0d0;
        border: 2px solid #a00000;
        border-radius: 8px;
        padding: 14px 25px;
        font-size: 1.2rem;
        margin: 10px;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(160, 0, 0, 0.4), 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
        width: 90%;
        max-width: 250px;
        text-align: center;
        font-family: 'Courier New', monospace;
        letter-spacing: 1px;
        transition: all 0.2s;
        position: relative;
        overflow: hidden;
    }
    
    .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s;
    }
    
    .btn:active {
        background: linear-gradient(145deg, #7a0000, #5a0000);
        transform: translateY(2px);
        box-shadow: 0 2px 8px rgba(160, 0, 0, 0.4);
    }
    
    .btn:active::before {
        left: 100%;
    }
    
    .mode-btn {
        background: linear-gradient(145deg, #003322, #002211);
        border-color: #006644;
        box-shadow: 0 5px 15px rgba(0, 100, 68, 0.4);
    }
    
    .easy { 
        background: linear-gradient(145deg, #003322, #002211);
        border-color: #00aa66;
    }
    
    .normal { 
        background: linear-gradient(145deg, #333322, #222211);
        border-color: #aaaa00;
    }
    
    .hard { 
        background: linear-gradient(145deg, #553322, #332211);
        border-color: #ff6600;
    }
    
    .impossible { 
        background: linear-gradient(145deg, #550000, #330000);
        border-color: #ff0000;
    }
    
    /* GAME VISUAL EFFECTS */
    #torch {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle 350px at var(--x,50%) var(--y,50%), 
                    rgba(200, 160, 100, 0.6) 0%, 
                    rgba(120, 80, 40, 0.4) 20%, 
                    rgba(0, 0, 0, 0.9) 70%);
        opacity: 0;
        pointer-events: none;
        z-index: 2;
        mix-blend-mode: lighten;
        transition: opacity 0.3s;
    }
    
    #vignette {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(ellipse at center, 
                    transparent 20%, 
                    rgba(0, 0, 0, 0.9) 60%);
        pointer-events: none;
        z-index: 4;
    }
    
    #blood {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at var(--blood-x,50%) var(--blood-y,50%), 
                    rgba(200, 0, 0, 0.8) 0%, 
                    rgba(120, 0, 0, 0.4) 15%, 
                    transparent 30%);
        opacity: 0;
        pointer-events: none;
        z-index: 3;
        mix-blend-mode: multiply;
    }
    
    #hideText {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 36px;
        color: #600;
        text-shadow: 0 0 20px #f00, 0 0 5px #000;
        opacity: 0;
        z-index: 999;
        letter-spacing: 6px;
        font-weight: bold;
        font-family: 'Courier New', monospace;
        transition: opacity 0.3s;
    }
    
    #hideStatus {
        position: absolute;
        top: 150px;
        left: 12px;
        background: rgba(20, 0, 0, 0.8);
        border: 2px solid #a00000;
        border-radius: 8px;
        padding: 8px 12px;
        color: #ffd0d0;
        font-size: 14px;
        font-weight: bold;
        z-index: 902;
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s;
    }
    
    #hideStatus.hidden {
        background: rgba(0, 50, 0, 0.8);
        border-color: #00aa00;
        color: #a0ffa0;
    }
    
    #hideStatusIcon {
        font-size: 16px;
    }
    
    #prompt {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(30, 0, 0, 0.85);
        border: 2px solid #a00000;
        border-radius: 8px;
        padding: 10px 20px;
        font-size: 16px;
        color: #ffd0d0;
        z-index: 999;
        display: none;
        text-align: center;
        max-width: 85%;
        backdrop-filter: blur(5px);
        box-shadow: 0 0 20px rgba(160, 0, 0, 0.5);
        font-family: 'Courier New', monospace;
    }
    
    /* BATTERY INDICATOR */
    #batteryIndicator {
        position: absolute;
        top: 180px;
        left: 12px;
        background: rgba(20, 20, 0, 0.8);
        border: 2px solid #cc0;
        border-radius: 8px;
        padding: 8px 12px;
        color: #ff0;
        font-size: 14px;
        font-weight: bold;
        z-index: 902;
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    #batteryIcon {
        font-size: 16px;
        color: #ff0;
    }
    
    #batteryLevel {
        width: 60px;
        height: 10px;
        background: #333;
        border-radius: 5px;
        overflow: hidden;
        margin-left: 5px;
    }
    
    #batteryFill {
        height: 100%;
        background: linear-gradient(90deg, #ff0, #0f0);
        width: 100%;
        transition: width 0.5s;
    }
    
    /* INVENTORY */
    #inventory {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 500px;
        background: rgba(20, 0, 20, 0.95);
        border: 3px solid #a000a0;
        border-radius: 12px;
        padding: 15px;
        z-index: 10000;
        display: none;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 40px rgba(160, 0, 160, 0.7);
    }
    
    .inventory-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        margin-top: 10px;
    }
    
    .inventory-item {
        background: rgba(40, 0, 40, 0.8);
        border: 2px solid #800080;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        min-height: 70px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .inventory-item:hover {
        background: rgba(80, 0, 80, 0.9);
        transform: scale(1.05);
    }
    
    .inventory-item:active {
        transform: scale(0.95);
    }
    
    .item-icon {
        font-size: 24px;
        margin-bottom: 5px;
    }
    
    .item-count {
        font-size: 12px;
        color: #ffd0d0;
    }
    
    /* MINIMAP */
    #miniMap {
        position: absolute;
        bottom: 120px;
        right: 12px;
        width: 150px;
        height: 150px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #a000a0;
        border-radius: 8px;
        z-index: 902;
        backdrop-filter: blur(5px);
        overflow: hidden;
    }
    
    #miniMapCanvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    
    /* MOBILE CONTROLS */
    #controls {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 900;
        pointer-events: none;
        touch-action: none;
    }
    
    /* HEALTH BAR - TOP */
    #healthBar {
        position: absolute;
        top: 12px;
        left: 12px;
        right: 12px;
        height: 20px;
        background: rgba(10, 0, 0, 0.7);
        border: 2px solid #a00000;
        border-radius: 4px;
        overflow: hidden;
        backdrop-filter: blur(4px);
    }
    
    #healthFill {
        height: 100%;
        background: linear-gradient(90deg, 
                    #00ff00 0%, 
                    #aaff00 33%, 
                    #ffff00 66%, 
                    #ff0000 100%);
        width: 100%;
        transition: width 0.3s ease;
    }
    
    #healthText {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-weight: bold;
        font-size: 10px;
        text-shadow: 1px 1px 2px #000;
        font-family: 'Courier New', monospace;
        letter-spacing: 0.5px;
    }
    
    /* FLOOR INDICATOR */
    #floorIndicator {
        position: absolute;
        top: 40px;
        left: 12px;
        background: rgba(10, 0, 10, 0.7);
        border: 2px solid #a000a0;
        border-radius: 6px;
        padding: 4px 8px;
        color: #f0c0f0;
        font-size: 12px;
        font-weight: bold;
        z-index: 902;
        backdrop-filter: blur(4px);
        font-family: 'Courier New', monospace;
    }
    
    /* JOYSTICK */
    #joystickArea {
        position: absolute;
        bottom: 15px;
        left: 15px;
        width: 100px;
        height: 100px;
        pointer-events: auto;
        z-index: 901;
    }
    
    #joystickBase {
        width: 100%;
        height: 100%;
        background: rgba(20, 0, 0, 0.6);
        border: 2px solid #600;
        border-radius: 50%;
        backdrop-filter: blur(5px);
    }
    
    #joystick {
        position: absolute;
        width: 45px;
        height: 45px;
        background: rgba(180, 0, 0, 0.8);
        border: 2px solid #c00;
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 15px rgba(200, 0, 0, 0.5);
    }
    
    /* ACTION BUTTONS */
    #actionBtn {
        position: absolute;
        bottom: 15px;
        right: 15px;
        width: 65px;
        height: 65px;
        background: rgba(30, 0, 30, 0.7);
        border: 3px solid #a000a0;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ffd0d0;
        font-size: 20px;
        font-weight: bold;
        box-shadow: 0 5px 15px rgba(160, 0, 160, 0.4);
        backdrop-filter: blur(5px);
        font-family: 'Courier New', monospace;
        pointer-events: auto;
        z-index: 901;
    }
    
    #actionBtn:active {
        background: rgba(200, 0, 200, 0.9);
        transform: scale(0.9);
    }
    
    #shootBtn {
        position: absolute;
        bottom: 90px;
        right: 15px;
        width: 65px;
        height: 65px;
        background: rgba(180, 0, 0, 0.7);
        border: 3px solid #c00;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ffd0d0;
        font-size: 22px;
        pointer-events: auto;
        z-index: 901;
        box-shadow: 0 5px 20px rgba(200, 0, 0, 0.5);
        backdrop-filter: blur(5px);
    }
    
    #shootBtn:active {
        background: rgba(255, 50, 50, 0.9);
        transform: scale(0.9);
    }
    
    /* FLASHLIGHT & INVENTORY BUTTONS */
    #flashlightBtn {
        position: absolute;
        top: 60px;
        right: 12px;
        width: 45px;
        height: 45px;
        background: rgba(40, 40, 0, 0.6);
        border: 2px solid #cc0;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ff0;
        font-size: 18px;
        pointer-events: auto;
        z-index: 901;
        box-shadow: 0 5px 15px rgba(204, 204, 0, 0.4);
        backdrop-filter: blur(5px);
    }
    
    #flashlightBtn:active {
        background: rgba(80, 80, 0, 0.9);
        transform: scale(0.9);
    }
    
    #inventoryBtn {
        position: absolute;
        top: 110px;
        right: 12px;
        width: 45px;
        height: 45px;
        background: rgba(0, 40, 80, 0.6);
        border: 2px solid #0af;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #0ff;
        font-size: 18px;
        font-weight: bold;
        pointer-events: auto;
        z-index: 901;
        box-shadow: 0 5px 15px rgba(0, 170, 255, 0.4);
        backdrop-filter: blur(5px);
    }
    
    #inventoryBtn:active {
        background: rgba(0, 80, 160, 0.9);
        transform: scale(0.9);
    }
    
    /* QUIT BUTTON */
    #quitBtn {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 45px;
        height: 45px;
        background: rgba(40, 0, 0, 0.7);
        border: 2px solid #c00;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #ffd0d0;
        font-size: 18px;
        pointer-events: auto;
        z-index: 902;
        box-shadow: 0 5px 15px rgba(200, 0, 0, 0.4);
        backdrop-filter: blur(5px);
    }
    
    #quitBtn:active {
        background: rgba(200, 0, 0, 0.9);
        transform: scale(0.9);
    }
    
    /* MODALS */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 10000;
        display: none;
        justify-content: center;
        align-items: center;
        padding: 15px;
    }
    
    .modal-content {
        background: linear-gradient(145deg, #1a001a, #0a000a);
        padding: 20px;
        border-radius: 12px;
        border: 3px solid #a000a0;
        text-align: center;
        max-width: 95%;
        width: 400px;
        box-shadow: 0 0 40px rgba(160, 0, 160, 0.6);
        position: relative;
        overflow: hidden;
    }
    
    .modal-content::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, transparent, #ff00ff, transparent);
    }
    
    /* RESPONSIVE */
    @media (max-width: 480px) {
        .screen h1 {
            font-size: 2.2rem;
        }
        
        .btn {
            font-size: 1rem;
            padding: 12px 18px;
            max-width: 220px;
            margin: 8px;
        }
        
        #joystickArea {
            width: 90px;
            height: 90px;
            bottom: 12px;
            left: 12px;
        }
        
        #joystick {
            width: 40px;
            height: 40px;
        }
        
        #actionBtn, #shootBtn {
            width: 60px;
            height: 60px;
            font-size: 18px;
            bottom: 12px;
            right: 12px;
        }
        
        #shootBtn {
            bottom: 85px;
            font-size: 20px;
        }
        
        #flashlightBtn, #inventoryBtn, #quitBtn {
            width: 40px;
            height: 40px;
            font-size: 16px;
        }
        
        #flashlightBtn {
            top: 55px;
            right: 10px;
        }
        
        #inventoryBtn {
            top: 100px;
            right: 10px;
        }
        
        #quitBtn {
            top: 10px;
            right: 10px;
        }
        
        #healthBar {
            height: 18px;
            top: 10px;
            left: 10px;
            right: 10px;
        }
        
        #healthText {
            font-size: 9px;
        }
        
        #hideStatus {
            top: 135px;
            left: 10px;
            font-size: 12px;
            padding: 6px 10px;
        }
        
        #batteryIndicator {
            top: 165px;
            left: 10px;
            font-size: 12px;
            padding: 6px 10px;
        }
        
        #floorIndicator {
            top: 35px;
            left: 10px;
            font-size: 11px;
            padding: 3px 6px;
        }
        
        #miniMap {
            width: 120px;
            height: 120px;
            bottom: 110px;
            right: 10px;
        }
        
        .inventory-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    }
</style>
</head>
<body>
<!-- SCREENS -->
<div id="startScreen" class="screen">
    <h1>CURSED APARTMENT</h1>
    
    <div style="font-size: 0.9rem; text-align: center; margin: 12px; background: rgba(30, 0, 30, 0.6); padding: 12px; border-radius: 8px; border: 1px solid #600060; max-width: 90%;">
        <div style="color: #a0f0ff; font-weight: bold; margin-bottom: 8px; font-size: 1rem;">üè¢ 12 FLOORS ‚Ä¢ BORO ROOMS ‚Ä¢ EXPLORE KORO!</div>
        <div style="margin: 5px 0;"><span style="color: #0f0">JOYSTICK:</span> MOVE (Camera follows)</div>
        <div style="margin: 5px 0;"><span style="color: #f80">üî´:</span> SHOOT (Touch to aim)</div>
        <div style="margin: 5px 0;"><span style="color: #ff0">A:</span> HIDE/INTERACT (Hide status shown)</div>
        <div style="margin: 5px 0;"><span style="color: #cc0">üî¶:</span> TORCH (Dark areas)</div>
        <div style="margin: 5px 0;"><span style="color: #0ff">F:</span> INVENTORY (Use items)</div>
        <div style="margin: 5px 0;"><span style="color: #f0f">‚ùå:</span> EXIT APP</div>
    </div>
    
    <button class="btn" id="startBtn">SELECT MODE</button>
</div>

<div id="modeScreen" class="screen">
    <h1>SELECT DIFFICULTY</h1>
    <button class="btn mode-btn easy" data-mode="easy">EASY</button>
    <button class="btn mode-btn normal" data-mode="normal">NORMAL</button>
    <button class="btn mode-btn hard" data-mode="hard">HARD</button>
    <button class="btn mode-btn impossible" data-mode="impossible">IMPOSSIBLE</button>
    <button class="btn" id="backBtn">BACK</button>
</div>

<div id="gameScreen" class="screen"></div>

<div id="winScreen" class="screen">
    <h1>ESCAPED!</h1>
    <p style="font-size: 1.3rem; margin: 15px; text-align: center; color: #a0ffa0;" id="winMessage">Freedom at last...</p>
    <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
</div>

<div id="gameoverScreen" class="screen">
    <h1>YOU DIED</h1>
    <p style="font-size: 1.3rem; margin: 15px; text-align: center; color: #ffa0a0;">The darkness consumed you...</p>
    <button class="btn" onclick="location.reload()">TRY AGAIN</button>
</div>

<!-- CANVAS -->
<canvas id="gameCanvas"></canvas>

<!-- MINIMAP CANVAS -->
<canvas id="miniMapCanvas"></canvas>

<!-- GAME EFFECTS -->
<div id="torch"></div>
<div id="vignette"></div>
<div id="blood"></div>
<div id="hideText">HIDING...</div>
<div id="prompt"></div>

<!-- HIDE STATUS -->
<div id="hideStatus">
    <div id="hideStatusIcon">üë§</div>
    <div>VISIBLE</div>
</div>

<!-- BATTERY INDICATOR -->
<div id="batteryIndicator">
    <div id="batteryIcon">üî¶</div>
    <div>TORCH:</div>
    <div id="batteryLevel">
        <div id="batteryFill"></div>
    </div>
</div>

<!-- INVENTORY -->
<div id="inventory">
    <h2 style="color: #f99; text-align: center; margin-bottom: 15px; font-size: 1.5rem;">INVENTORY</h2>
    <div class="inventory-grid" id="inventoryGrid">
        <!-- Items will be added here dynamically -->
    </div>
    <button onclick="closeInventory()" class="btn" style="margin-top: 15px; width: 100%;">CLOSE</button>
</div>

<!-- MINIMAP -->
<div id="miniMap">
    <!-- Minimap canvas is here -->
</div>

<!-- MOBILE CONTROLS -->
<div id="controls">
    <div id="healthBar">
        <div id="healthFill"></div>
        <div id="healthText">HP: 100 | KEYS: 0/5 | CAR PARTS: 0/10</div>
    </div>
    
    <div id="floorIndicator">FLOOR: 1 (BASEMENT)</div>
    
    <div id="quitBtn">‚ùå</div>
    
    <div id="joystickArea">
        <div id="joystickBase"></div>
        <div id="joystick"></div>
    </div>
    
    <div id="shootBtn">üî´</div>
    
    <div id="actionBtn">A</div>
    
    <div id="flashlightBtn">üî¶</div>
    
    <div id="inventoryBtn">F</div>
</div>

<!-- MODALS -->
<div id="puzzleModal" class="modal">
    <div class="modal-content">
        <h2 style="color: #f99; margin-bottom: 12px; font-size: 1.6rem;">SOLVE PUZZLE</h2>
        <p id="puzzleQuestion" style="font-size: 1.4rem; color: #0ff; margin: 12px 0; min-height: 60px; display: flex; align-items: center; justify-content: center; text-align: center;"></p>
        <input type="text" id="puzzleAnswer" style="width: 100%; padding: 10px; font-size: 1.2rem; text-align: center; background: #111; color: #fff; border: 2px solid #600; border-radius: 6px; margin: 10px 0;" placeholder="Enter answer..." autocomplete="off">
        <div style="display: flex; gap: 8px; margin-top: 15px;">
            <button id="submitPuzzle" class="btn" style="flex: 1; padding: 10px; font-size: 1.1rem;">SUBMIT</button>
            <button onclick="closePuzzle()" class="btn" style="background: #400; border-color: #600; padding: 10px; font-size: 1.1rem;">CANCEL</button>
        </div>
    </div>
</div>

<!-- AUDIO -->
<audio id="bgm" loop src="https://assets.codepen.io/605876/creepy-horror-ambience.mp3"></audio>
<audio id="gunSound" src="https://assets.codepen.io/605876/gunshot.mp3"></audio>
<audio id="hitSound" src="https://assets.codepen.io/605876/hit-marker.mp3"></audio>
<audio id="scareSound" src="https://assets.codepen.io/605876/jumpscare-scream.mp3"></audio>

<script>
// ============================================
// FULLSCREEN MANAGEMENT
// ============================================
function requestFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) elem.requestFullscreen();
    else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
    else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
    
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        setTimeout(() => window.scrollTo(0, 1), 100);
    }
}

// Automatically go fullscreen
window.addEventListener('load', () => {
    setTimeout(() => requestFullscreen(), 500);
});

window.addEventListener('orientationchange', () => {
    setTimeout(() => requestFullscreen(), 300);
});

// ============================================
// GAME VARIABLES - BORO ROOMS
// ============================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniMapCanvas = document.getElementById('miniMapCanvas');
const miniMapCtx = miniMapCanvas.getContext('2d');

// Set canvas sizes - VERY LARGE FOR BIG ROOMS
canvas.width = 4000;
canvas.height = 4000;
miniMapCanvas.width = 150;
miniMapCanvas.height = 150;

// Game world size
const WORLD_WIDTH = 4000;
const WORLD_HEIGHT = 4000;

// Viewport (camera) variables
let cameraX = 0;
let cameraY = 0;
let VIEWPORT_WIDTH = window.innerWidth;
let VIEWPORT_HEIGHT = window.innerHeight;

// Room settings - BORO ROOMS
const ROOM_WIDTH = 800;  // 2x bigger
const ROOM_HEIGHT = 600; // 2x bigger

let gameMode = 'easy';
let player = {
    x: WORLD_WIDTH/2,
    y: WORLD_HEIGHT/2,
    hp: 100,
    keys: 0,
    bullets: 30,
    carParts: 0,
    helicopterKey: false,
    oilCan: false,
    ductTape: false,
    vx: 0,
    vy: 0,
    speed: 5.0, // Faster for bigger rooms
    hidden: false,
    size: 25,
    hidingSpot: null
};

let floor = 1;
let torchOn = false;
let battery = 100;
let ghosts = [];
let puzzles = [];
let stairsUp = null;
let stairsDown = null;
let elevator = null;
let exitDoor = null;
let carRoom = null;
let garageDoor = null;
let hidingSpots = [];
let bullets = [];
let monster = null;
let helicopter = null;
let gameRunning = false;
let gameLoopId = null;
let puzzlesSolved = 0;
let totalPuzzles = 20;
let inventory = {
    'car_part': 0,
    'health_pack': 0,
    'battery_pack': 0,
    'ammo': 0
};

// Map rooms - BORO ROOMS
let rooms = [];

// Joystick variables
let joystickActive = false;
let joystickX = 0;
let joystickY = 0;
let joystickStartX = 0;
let joystickStartY = 0;
const JOYSTICK_RADIUS = 40; // Bigger joystick

// Shoot aiming variables
let shootTouchX = 0;
let shootTouchY = 0;

// Hide variables
let nearHidingSpot = false;

// ============================================
// CAMERA SYSTEM
// ============================================
function updateCamera() {
    // Smooth camera follow
    const targetX = player.x - VIEWPORT_WIDTH / 2;
    const targetY = player.y - VIEWPORT_HEIGHT / 2;
    
    // Smooth interpolation
    cameraX += (targetX - cameraX) * 0.08; // Slower follow for smoother experience
    cameraY += (targetY - cameraY) * 0.08;
    
    // Clamp camera to world bounds
    cameraX = Math.max(0, Math.min(WORLD_WIDTH - VIEWPORT_WIDTH, cameraX));
    cameraY = Math.max(0, Math.min(WORLD_HEIGHT - VIEWPORT_HEIGHT, cameraY));
    
    // Apply camera transform to canvas
    canvas.style.transform = `translate(${-cameraX}px, ${-cameraY}px)`;
    
    // Update torch position relative to viewport
    const torch = document.getElementById('torch');
    const viewportX = player.x - cameraX;
    const viewportY = player.y - cameraY;
    torch.style.setProperty('--x', viewportX + 'px');
    torch.style.setProperty('--y', viewportY + 'px');
}

// ============================================
// SCREEN MANAGEMENT
// ============================================
function showScreen(screenId) {
    ['startScreen','modeScreen','gameScreen','winScreen','gameoverScreen'].forEach(id => {
        document.getElementById(id).style.display = 'none';
    });
    
    document.getElementById(screenId).style.display = 'flex';
    requestFullscreen();
    
    if (screenId === 'gameScreen') {
        canvas.style.display = 'block';
        document.getElementById('controls').style.display = 'block';
        document.getElementById('torch').style.display = 'block';
        document.getElementById('vignette').style.display = 'block';
        document.getElementById('blood').style.display = 'block';
        document.getElementById('hideText').style.display = 'block';
        document.getElementById('prompt').style.display = 'block';
        document.getElementById('hideStatus').style.display = 'flex';
        document.getElementById('batteryIndicator').style.display = 'flex';
        document.getElementById('miniMap').style.display = 'block';
        document.getElementById('floorIndicator').style.display = 'block';
        
        if (!gameRunning) startGame();
    } else {
        canvas.style.display = 'none';
        document.getElementById('controls').style.display = 'none';
        document.getElementById('torch').style.display = 'none';
        document.getElementById('vignette').style.display = 'none';
        document.getElementById('blood').style.display = 'none';
        document.getElementById('hideText').style.display = 'none';
        document.getElementById('prompt').style.display = 'none';
        document.getElementById('hideStatus').style.display = 'none';
        document.getElementById('batteryIndicator').style.display = 'none';
        document.getElementById('miniMap').style.display = 'none';
        document.getElementById('floorIndicator').style.display = 'none';
        
        if (gameRunning) {
            gameRunning = false;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            document.getElementById('bgm').pause();
        }
    }
}

// ============================================
// GAME INITIALIZATION
// ============================================
document.getElementById('startBtn').onclick = () => showScreen('modeScreen');
document.getElementById('backBtn').onclick = () => showScreen('startScreen');

document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.onclick = function() {
        gameMode = this.dataset.mode;
        showScreen('gameScreen');
    };
});

function startGame() {
    console.log("Starting game in", gameMode, "mode");
    
    if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
    }
    
    // Reset game state
    gameRunning = true;
    player = {
        x: WORLD_WIDTH/2,
        y: WORLD_HEIGHT/2,
        hp: 100,
        keys: 0,
        bullets: 30,
        carParts: 0,
        helicopterKey: false,
        oilCan: false,
        ductTape: false,
        vx: 0,
        vy: 0,
        speed: 5.0,
        hidden: false,
        size: 25,
        hidingSpot: null
    };
    
    floor = 1;
    torchOn = false;
    battery = 100;
    ghosts = [];
    puzzles = [];
    stairsUp = null;
    stairsDown = null;
    elevator = null;
    exitDoor = null;
    carRoom = null;
    garageDoor = null;
    hidingSpots = [];
    bullets = [];
    monster = null;
    helicopter = null;
    puzzlesSolved = 0;
    
    inventory = {
        'car_part': 0,
        'health_pack': 0,
        'battery_pack': 0,
        'ammo': 15
    };
    
    // Generate BIG rooms for exploration
    generateBoroRooms();
    
    updateUI();
    updateFloorIndicator();
    updateInventory();
    updateHideStatus();
    updateBatteryDisplay();
    
    // Start audio
    const bgm = document.getElementById('bgm');
    bgm.volume = 0.3;
    bgm.currentTime = 0;
    bgm.play().catch(e => console.log("Audio error:", e));
    
    // Initialize basement (floor 1)
    initFloor(1);
    
    // Start game loop
    gameLoop();
}

// ============================================
// BORO ROOM GENERATION
// ============================================
function generateBoroRooms() {
    rooms = [];
    
    // Generate 12 rooms with BIG sizes
    // Floors 1-6: Left side
    for (let i = 0; i < 6; i++) {
        rooms.push({
            x: 200,
            y: 200 + i * (ROOM_HEIGHT + 100),
            width: ROOM_WIDTH,
            height: ROOM_HEIGHT,
            floor: i + 1,
            visited: false
        });
    }
    
    // Floors 7-11: Right side
    for (let i = 6; i < 11; i++) {
        rooms.push({
            x: WORLD_WIDTH - ROOM_WIDTH - 200,
            y: 200 + (i - 6) * (ROOM_HEIGHT + 100),
            width: ROOM_WIDTH,
            height: ROOM_HEIGHT,
            floor: i + 1,
            visited: false
        });
    }
    
    // Rooftop (floor 12) - Center top
    rooms.push({
        x: WORLD_WIDTH/2 - ROOM_WIDTH/2,
        y: 100,
        width: ROOM_WIDTH,
        height: ROOM_HEIGHT,
        floor: 12,
        visited: false,
        isRooftop: true
    });
}

// ============================================
// HIDE STATUS SYSTEM
// ============================================
function updateHideStatus() {
    const hideStatus = document.getElementById('hideStatus');
    const hideIcon = document.getElementById('hideStatusIcon');
    
    if (player.hidden) {
        hideStatus.classList.add('hidden');
        hideIcon.textContent = 'üëª';
        hideStatus.querySelector('div:last-child').textContent = 'HIDDEN';
        document.getElementById('hideText').style.opacity = 1;
    } else {
        hideStatus.classList.remove('hidden');
        hideIcon.textContent = 'üë§';
        hideStatus.querySelector('div:last-child').textContent = 'VISIBLE';
        document.getElementById('hideText').style.opacity = 0;
    }
}

// ============================================
// BATTERY DISPLAY
// ============================================
function updateBatteryDisplay() {
    const batteryFill = document.getElementById('batteryFill');
    batteryFill.style.width = battery + '%';
    
    // Change color based on battery level
    if (battery > 50) {
        batteryFill.style.background = 'linear-gradient(90deg, #0f0, #ff0)';
    } else if (battery > 20) {
        batteryFill.style.background = 'linear-gradient(90deg, #ff0, #f00)';
    } else {
        batteryFill.style.background = '#f00';
    }
}

// ============================================
// MOBILE CONTROLS
// ============================================
// Quit Button - EXIT APP
document.getElementById('quitBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    exitApp();
}, { passive: false });

// Joystick
const joystickArea = document.getElementById('joystickArea');
const joystick = document.getElementById('joystick');

joystickArea.addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!gameRunning) return;
    
    joystickActive = true;
    const touch = e.touches[0];
    const rect = joystickArea.getBoundingClientRect();
    joystickStartX = rect.left + rect.width/2;
    joystickStartY = rect.top + rect.height/2;
    
    updateJoystick(touch.clientX, touch.clientY);
}, { passive: false });

joystickArea.addEventListener('touchmove', function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!joystickActive || !gameRunning) return;
    
    const touch = e.touches[0];
    updateJoystick(touch.clientX, touch.clientY);
}, { passive: false });

joystickArea.addEventListener('touchend', function(e) {
    e.preventDefault();
    e.stopPropagation();
    joystickActive = false;
    joystickX = 0;
    joystickY = 0;
    joystick.style.transform = 'translate(-50%, -50%)';
});

function updateJoystick(touchX, touchY) {
    let dx = touchX - joystickStartX;
    let dy = touchY - joystickStartY;
    const distance = Math.sqrt(dx*dx + dy*dy);
    
    if (distance > JOYSTICK_RADIUS) {
        dx = (dx/distance) * JOYSTICK_RADIUS;
        dy = (dy/distance) * JOYSTICK_RADIUS;
    }
    
    joystickX = dx;
    joystickY = dy;
    joystick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
}

// SHOOT BUTTON
const shootBtn = document.getElementById('shootBtn');

shootBtn.addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!gameRunning || player.bullets <= 0) return;
    
    const touch = e.touches[0];
    // Convert screen touch to world coordinates
    shootTouchX = touch.clientX + cameraX;
    shootTouchY = touch.clientY + cameraY;
    
    // Calculate bullet direction
    const bulletDirectionX = shootTouchX - player.x;
    const bulletDirectionY = shootTouchY - player.y;
    const distance = Math.sqrt(bulletDirectionX * bulletDirectionX + bulletDirectionY * bulletDirectionY);
    
    if (distance > 10) {
        const dirX = bulletDirectionX / distance;
        const dirY = bulletDirectionY / distance;
        const targetX = player.x + dirX * 800; // Longer range for bigger rooms
        const targetY = player.y + dirY * 800;
        
        shootBullet(targetX, targetY);
    }
}, { passive: false });

function shootBullet(targetX, targetY) {
    player.bullets--;
    updateUI();
    
    // Play gun sound
    const gunSound = document.getElementById('gunSound');
    gunSound.currentTime = 0;
    gunSound.play().catch(e => console.log("Gun sound error"));
    
    // Create bullet
    bullets.push({
        x: player.x,
        y: player.y,
        tx: targetX,
        ty: targetY,
        life: 60 // Longer life for bigger rooms
    });
    
    // Check hit with ghosts
    ghosts = ghosts.filter(g => {
        const bulletStartX = player.x;
        const bulletStartY = player.y;
        const bulletEndX = player.x + (targetX - player.x) * 0.3;
        const bulletEndY = player.y + (targetY - player.y) * 0.3;
        
        const distanceToLine = pointToLineDistance(g.x, g.y, bulletStartX, bulletStartY, bulletEndX, bulletEndY);
        
        if (distanceToLine < 60) { // Bigger hit radius
            document.getElementById('hitSound').currentTime = 0;
            document.getElementById('hitSound').play().catch(e => console.log("Hit sound error"));
            
            // Blood effect
            document.getElementById('blood').style.setProperty('--blood-x', (g.x - cameraX) + 'px');
            document.getElementById('blood').style.setProperty('--blood-y', (g.y - cameraY) + 'px');
            document.getElementById('blood').style.opacity = 1;
            setTimeout(() => {
                document.getElementById('blood').style.opacity = 0;
            }, 500);
            
            // Blood particles
            for (let i = 0; i < 8; i++) { // More blood
                bullets.push({
                    x: g.x,
                    y: g.y,
                    tx: g.x + (Math.random()-0.5)*200,
                    ty: g.y + (Math.random()-0.5)*200,
                    life: 25,
                    blood: true
                });
            }
            
            return false;
        }
        return true;
    });
    
    // Check hit with monster
    if (monster && Math.hypot(monster.x - player.x, monster.y - player.y) < 400) {
        const bulletStartX = player.x;
        const bulletStartY = player.y;
        const bulletEndX = player.x + (targetX - player.x) * 0.3;
        const bulletEndY = player.y + (targetY - player.y) * 0.3;
        
        const distanceToLine = pointToLineDistance(monster.x, monster.y, bulletStartX, bulletStartY, bulletEndX, bulletEndY);
        
        if (distanceToLine < 100) { // Bigger hit radius for monster
            monster.hp -= 8;
            if (monster.hp <= 0) {
                monster = null;
                showAlert("üéâ MONSTER DEFEATED! Check car for key!");
            }
        }
    }
}

// Calculate distance from point to line
function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
        param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
}

// SINGLE ACTION BUTTON - HIDE/INTERACT
const actionBtn = document.getElementById('actionBtn');

actionBtn.addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!gameRunning) return;
    
    if (player.hidden) {
        player.hidden = false;
        player.hidingSpot = null;
        updateHideStatus();
        
        ghosts.forEach(g => {
            g.wandering = false;
        });
    } else if (nearHidingSpot) {
        player.hidden = true;
        updateHideStatus();
        
        let closestSpot = null;
        let closestDistance = Infinity;
        
        hidingSpots.forEach(spot => {
            const dist = Math.hypot(spot.x - player.x, spot.y - player.y);
            if (dist < 80 && dist < closestDistance) { // Bigger hide range
                closestDistance = dist;
                closestSpot = spot;
            }
        });
        
        if (closestSpot) {
            player.hidingSpot = closestSpot;
            player.x = closestSpot.x;
            player.y = closestSpot.y;
        }
        
        ghosts.forEach(g => {
            g.wandering = true;
            g.wanderTargetX = g.x + (Math.random()-0.5)*300;
            g.wanderTargetY = g.y + (Math.random()-0.5)*300;
        });
        
        setTimeout(() => {
            if (player.hidden) {
                document.getElementById('hideText').style.opacity = 0.3;
            }
        }, 1500);
    } else {
        // Check puzzle interaction
        for (let puzzle of puzzles) {
            if (!puzzle.solved && Math.hypot(puzzle.x - player.x, puzzle.y - player.y) < 90) { // Bigger range
                openPuzzle(puzzle);
                return;
            }
        }
        
        // Check elevator
        if (elevator && Math.hypot(elevator.x - player.x, elevator.y - player.y) < 120) { // Bigger range
            changeFloorViaElevator();
            return;
        }
        
        // Check stairs
        if (stairsDown && Math.hypot(stairsDown.x - player.x, stairsDown.y - player.y) < 80) {
            changeFloor(stairsDown.to);
            return;
        }
        
        if (stairsUp && Math.hypot(stairsUp.x - player.x, stairsUp.y - player.y) < 80) {
            changeFloor(stairsUp.to);
            return;
        }
        
        // Check car
        if (carRoom && Math.hypot(carRoom.x - player.x, carRoom.y - player.y) < 150) {
            if (player.carParts >= 10) {
                showAlert("üöó Car is fully repaired! Now find the garage door!");
            } else {
                showAlert(`üöó Car needs ${10 - player.carParts} more parts to repair!`);
            }
            return;
        }
        
        // Check garage door
        if (garageDoor && player.carParts >= 10 && Math.hypot(garageDoor.x - player.x, garageDoor.y - player.y) < 120) {
            winGame('car');
            return;
        }
        
        // Check helicopter
        if (helicopter && Math.hypot(helicopter.x - player.x, helicopter.y - player.y) < 120) {
            if (player.helicopterKey && player.oilCan && player.ductTape) {
                winGame('helicopter');
            } else {
                let missing = [];
                if (!player.helicopterKey) missing.push("helicopter key");
                if (!player.oilCan) missing.push("oil can");
                if (!player.ductTape) missing.push("duct tape");
                showAlert(`üöÅ Need: ${missing.join(", ")}!`);
            }
            return;
        }
        
        // Check monster for helicopter key
        if (!monster && floor === 11 && Math.abs(player.x - carRoom.x) < 150 && Math.abs(player.y - carRoom.y) < 100) {
            player.helicopterKey = true;
            showAlert("üîë Found Helicopter Key in the car!");
            updateInventory();
            return;
        }
        
        // Check for oil can and duct tape on rooftop
        if (floor === 12 && helicopter) {
            if (Math.abs(player.x - (helicopter.x - 200)) < 100 && Math.abs(player.y - helicopter.y) < 100 && !player.oilCan) {
                player.oilCan = true;
                showAlert("üõ¢Ô∏è Found Oil Can!");
                updateInventory();
                return;
            }
            if (Math.abs(player.x - (helicopter.x + 200)) < 100 && Math.abs(player.y - helicopter.y) < 100 && !player.ductTape) {
                player.ductTape = true;
                showAlert("üéûÔ∏è Found Duct Tape!");
                updateInventory();
                return;
            }
        }
    }
}, { passive: false });

// Flashlight Button
document.getElementById('flashlightBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (battery > 0) {
        torchOn = !torchOn;
        const btn = document.getElementById('flashlightBtn');
        btn.style.background = torchOn ? 'rgba(100,100,0,0.9)' : 'rgba(40,40,0,0.6)';
        btn.style.borderColor = torchOn ? '#ff0' : '#cc0';
        
        // Update torch visibility
        document.getElementById('torch').style.opacity = torchOn ? 1 : 0;
    } else {
        showAlert("üîã Torch battery empty!");
        torchOn = false;
        const btn = document.getElementById('flashlightBtn');
        btn.style.background = 'rgba(40,40,0,0.6)';
        btn.style.borderColor = '#cc0';
        document.getElementById('torch').style.opacity = 0;
    }
}, { passive: false });

// Inventory Button
document.getElementById('inventoryBtn').addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    openInventory();
}, { passive: false });

function changeFloorViaElevator() {
    let floors = [];
    for (let i = 1; i <= 12; i++) {
        if (i !== floor) floors.push(i);
    }
    
    const randomFloor = floors[Math.floor(Math.random() * floors.length)];
    showAlert(`üè¢ Elevator taking you to Floor ${randomFloor}...`);
    setTimeout(() => {
        changeFloor(randomFloor);
    }, 1000);
}

// ============================================
// INVENTORY SYSTEM
// ============================================
function openInventory() {
    updateInventory();
    document.getElementById('inventory').style.display = 'block';
}

function closeInventory() {
    document.getElementById('inventory').style.display = 'none';
}

function updateInventory() {
    const grid = document.getElementById('inventoryGrid');
    grid.innerHTML = '';
    
    // Car Parts
    if (inventory.car_part > 0) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">üîß</div>
            <div>Car Part</div>
            <div class="item-count">${inventory.car_part}</div>
        `;
        item.onclick = () => useItem('car_part');
        grid.appendChild(item);
    }
    
    // Health Packs
    if (inventory.health_pack > 0) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">‚ù§Ô∏è</div>
            <div>Health Pack</div>
            <div class="item-count">${inventory.health_pack}</div>
        `;
        item.onclick = () => useItem('health_pack');
        grid.appendChild(item);
    }
    
    // Battery Packs
    if (inventory.battery_pack > 0) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">üîã</div>
            <div>Battery</div>
            <div class="item-count">${inventory.battery_pack}</div>
        `;
        item.onclick = () => useItem('battery_pack');
        grid.appendChild(item);
    }
    
    // Ammo
    if (inventory.ammo > 0) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">üî´</div>
            <div>Ammo</div>
            <div class="item-count">${inventory.ammo}</div>
        `;
        item.onclick = () => useItem('ammo');
        grid.appendChild(item);
    }
    
    // Helicopter Items
    if (player.helicopterKey) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">üöÅ</div>
            <div>Helicopter Key</div>
            <div class="item-count">KEY</div>
        `;
        grid.appendChild(item);
    }
    
    if (player.oilCan) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">üõ¢Ô∏è</div>
            <div>Oil Can</div>
            <div class="item-count">OIL</div>
        `;
        grid.appendChild(item);
    }
    
    if (player.ductTape) {
        const item = document.createElement('div');
        item.className = 'inventory-item';
        item.innerHTML = `
            <div class="item-icon">üéûÔ∏è</div>
            <div>Duct Tape</div>
            <div class="item-count">TAPE</div>
        `;
        grid.appendChild(item);
    }
}

function useItem(type) {
    switch(type) {
        case 'health_pack':
            if (inventory.health_pack > 0) {
                player.hp = Math.min(100, player.hp + 50);
                inventory.health_pack--;
                showAlert("‚ù§Ô∏è +50 HP!");
                updateUI();
                updateInventory();
            }
            break;
            
        case 'battery_pack':
            if (inventory.battery_pack > 0) {
                battery = Math.min(100, battery + 50);
                inventory.battery_pack--;
                showAlert("üîã +50% Battery!");
                updateBatteryDisplay();
                updateInventory();
            }
            break;
            
        case 'ammo':
            if (inventory.ammo > 0) {
                player.bullets += 15;
                inventory.ammo--;
                showAlert("üî´ +15 Bullets!");
                updateUI();
                updateInventory();
            }
            break;
            
        case 'car_part':
            showAlert("Car parts automatically used when collected!");
            break;
    }
}

// ============================================
// GAME LOGIC - BORO ROOMS
// ============================================
function initFloor(f) {
    floor = f;
    ghosts = [];
    puzzles = [];
    stairsUp = null;
    stairsDown = null;
    elevator = null;
    exitDoor = null;
    carRoom = null;
    garageDoor = null;
    hidingSpots = [];
    bullets = [];
    monster = null;
    helicopter = null;
    
    // Get current room for this floor
    const room = rooms.find(r => r.floor === f) || rooms[0];
    room.visited = true;
    
    // Set player position to room center
    player.x = room.x + room.width/2;
    player.y = room.y + room.height/2;
    
    // Ghost settings based on difficulty
    let ghostCount = 3;
    let ghostSpeed = 1.5;
    let ghostDamage = 0.25;
    let ghostSize = 40; // Bigger ghosts for bigger rooms
    
    switch(gameMode) {
        case 'easy': 
            ghostCount = 2; 
            ghostSpeed = 1.2; 
            ghostDamage = 0.15; 
            ghostSize = 35;
            break;
        case 'normal': 
            ghostCount = 3; 
            ghostSpeed = 1.5; 
            ghostDamage = 0.25; 
            ghostSize = 40;
            break;
        case 'hard': 
            ghostCount = 4; 
            ghostSpeed = 1.8; 
            ghostDamage = 0.35; 
            ghostSize = 45;
            break;
        case 'impossible': 
            ghostCount = 5; 
            ghostSpeed = 2.1; 
            ghostDamage = 0.45; 
            ghostSize = 50;
            break;
    }
    
    // Create ghosts
    for (let i = 0; i < ghostCount; i++) {
        ghosts.push({
            x: room.x + 100 + Math.random()*(room.width-200),
            y: room.y + 100 + Math.random()*(room.height-200),
            speed: ghostSpeed + Math.random()*0.5,
            damage: ghostDamage,
            size: ghostSize,
            wandering: false,
            wanderTargetX: 0,
            wanderTargetY: 0
        });
    }
    
    // Create puzzles (2 per floor for floors 1-10)
    if (f <= 10) {
        for (let i = 0; i < 2; i++) {
            puzzles.push({
                x: room.x + 150 + (i * 400),
                y: room.y + room.height/2,
                solved: false,
                floor: f,
                index: i
            });
        }
    }
    
    // Special room 11 (car room)
    if (f === 11) {
        carRoom = {x: room.x + room.width/2, y: room.y + room.height/2};
        garageDoor = {x: room.x + room.width/2, y: room.y + 120};
        monster = {
            x: room.x + room.width/2,
            y: room.y + 200,
            hp: 1500, // More HP for bigger room
            size: 100, // Bigger monster
            speed: 0.9
        };
        
        // Add some extra hiding spots in car room
        hidingSpots.push(
            {x: room.x + 150, y: room.y + 150},
            {x: room.x + room.width - 150, y: room.y + 150},
            {x: room.x + 150, y: room.y + room.height - 150},
            {x: room.x + room.width - 150, y: room.y + room.height - 150}
        );
    }
    
    // Basement (floor 1) - dark with rope
    if (f === 1) {
        // Rope in basement - bigger
        puzzles.push({
            x: room.x + room.width - 200,
            y: room.y + 150,
            solved: false,
            floor: f,
            index: 2,
            special: 'rope'
        });
        
        // Turn on torch automatically in basement
        torchOn = true;
        document.getElementById('torch').style.opacity = 1;
        document.getElementById('flashlightBtn').style.background = 'rgba(100,100,0,0.9)';
        document.getElementById('flashlightBtn').style.borderColor = '#ff0';
        
        // Basement is extra dark
        document.getElementById('torch').style.background = 
            'radial-gradient(circle 400px at var(--x,50%) var(--y,50%), ' +
            'rgba(200, 160, 100, 0.7) 0%, ' +
            'rgba(120, 80, 40, 0.5) 20%, ' +
            'rgba(0, 0, 0, 0.95) 80%)';
    }
    
    // Floor 10 - garage key
    if (f === 10) {
        puzzles.push({
            x: room.x + room.width/2,
            y: room.y + room.height/2,
            solved: false,
            floor: f,
            index: 0,
            special: 'garage_key'
        });
    }
    
    // Rooftop (floor 12) - helicopter
    if (f === 12) {
        helicopter = {x: room.x + room.width/2, y: room.y + room.height/2 - 150};
        // Oil can and duct tape spawn points
        puzzles.push({
            x: helicopter.x - 200,
            y: helicopter.y,
            solved: false,
            floor: f,
            index: 0,
            special: 'oil_can'
        });
        puzzles.push({
            x: helicopter.x + 200,
            y: helicopter.y,
            solved: false,
            floor: f,
            index: 1,
            special: 'duct_tape'
        });
    }
    
    // Elevator and stairs - positioned properly in big rooms
    elevator = {x: room.x + room.width/2, y: room.y + room.height - 120};
    if (f > 1) stairsDown = {x: room.x + 100, y: room.y + room.height/2, to: f-1};
    if (f < 12) stairsUp = {x: room.x + room.width - 100, y: room.y + room.height/2, to: f+1};
    
    // More hiding spots in big rooms
    hidingSpots.push(
        {x: room.x + 100, y: room.y + 100},
        {x: room.x + 100, y: room.y + room.height - 100},
        {x: room.x + room.width - 100, y: room.y + 100},
        {x: room.x + room.width - 100, y: room.y + room.height - 100},
        {x: room.x + room.width/2, y: room.y + 100},
        {x: room.x + room.width/2, y: room.y + room.height - 100}
    );
    
    updateFloorIndicator();
    updateUI();
    updateHideStatus();
    updateMiniMap();
}

function updateUI() {
    document.getElementById('healthFill').style.width = player.hp + '%';
    document.getElementById('healthText').textContent = 
        `HP: ${Math.floor(player.hp)} | KEYS: ${player.keys}/5 | CAR PARTS: ${player.carParts}/10 | BULLETS: ${player.bullets}`;
}

function updateFloorIndicator() {
    let floorName = "FLOOR: " + floor;
    if (floor === 1) floorName = "FLOOR: 1 (BASEMENT - DARK)";
    else if (floor === 11) floorName = "FLOOR: 11 (CAR & MONSTER)";
    else if (floor === 12) floorName = "FLOOR: 12 (ROOFTOP)";
    document.getElementById('floorIndicator').textContent = floorName;
}

// ============================================
// MINIMAP
// ============================================
function updateMiniMap() {
    miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
    
    // Draw rooms
    rooms.forEach(room => {
        // Convert world coordinates to minimap coordinates
        const mapX = (room.x / WORLD_WIDTH) * miniMapCanvas.width;
        const mapY = (room.y / WORLD_HEIGHT) * miniMapCanvas.height;
        const mapWidth = (room.width / WORLD_WIDTH) * miniMapCanvas.width;
        const mapHeight = (room.height / WORLD_HEIGHT) * miniMapCanvas.height;
        
        // Draw room
        miniMapCtx.fillStyle = room.visited ? (room.floor === floor ? '#ff0' : '#666') : '#333';
        miniMapCtx.fillRect(mapX, mapY, mapWidth, mapHeight);
        
        // Draw room border
        miniMapCtx.strokeStyle = room.visited ? '#fff' : '#555';
        miniMapCtx.lineWidth = 1;
        miniMapCtx.strokeRect(mapX, mapY, mapWidth, mapHeight);
        
        // Draw floor number
        if (room.visited) {
            miniMapCtx.fillStyle = '#fff';
            miniMapCtx.font = '8px Courier New';
            miniMapCtx.textAlign = 'center';
            miniMapCtx.fillText(room.floor.toString(), mapX + mapWidth/2, mapY + mapHeight/2 + 3);
        }
    });
    
    // Draw player on minimap
    const playerMapX = (player.x / WORLD_WIDTH) * miniMapCanvas.width;
    const playerMapY = (player.y / WORLD_HEIGHT) * miniMapCanvas.height;
    
    miniMapCtx.fillStyle = player.hidden ? '#0f0' : '#f00';
    miniMapCtx.beginPath();
    miniMapCtx.arc(playerMapX, playerMapY, 4, 0, Math.PI * 2);
    miniMapCtx.fill();
    
    // Draw player direction indicator
    if (player.vx !== 0 || player.vy !== 0) {
        const angle = Math.atan2(player.vy, player.vx);
        const arrowX = playerMapX + Math.cos(angle) * 8;
        const arrowY = playerMapY + Math.sin(angle) * 8;
        
        miniMapCtx.strokeStyle = '#fff';
        miniMapCtx.lineWidth = 1;
        miniMapCtx.beginPath();
        miniMapCtx.moveTo(playerMapX, playerMapY);
        miniMapCtx.lineTo(arrowX, arrowY);
        miniMapCtx.stroke();
    }
    
    // Draw ghosts on minimap
    ghosts.forEach(ghost => {
        const ghostMapX = (ghost.x / WORLD_WIDTH) * miniMapCanvas.width;
        const ghostMapY = (ghost.y / WORLD_HEIGHT) * miniMapCanvas.height;
        
        miniMapCtx.fillStyle = '#f0f';
        miniMapCtx.beginPath();
        miniMapCtx.arc(ghostMapX, ghostMapY, 3, 0, Math.PI * 2);
        miniMapCtx.fill();
    });
    
    // Draw monster on minimap
    if (monster) {
        const monsterMapX = (monster.x / WORLD_WIDTH) * miniMapCanvas.width;
        const monsterMapY = (monster.y / WORLD_HEIGHT) * miniMapCanvas.height;
        
        miniMapCtx.fillStyle = '#800';
        miniMapCtx.beginPath();
        miniMapCtx.arc(monsterMapX, monsterMapY, 6, 0, Math.PI * 2);
        miniMapCtx.fill();
    }
}

// ============================================
// GAME LOOP - BORO ROOMS
// ============================================
function gameLoop() {
    if (!gameRunning) return;
    
    try {
        // Update camera
        updateCamera();
        
        // Clear canvas with appropriate color
        if (floor === 1) {
            ctx.fillStyle = '#030303'; // Extra dark for basement
        } else {
            ctx.fillStyle = '#080808';
        }
        ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        
        // Get current room
        const currentRoom = rooms.find(r => r.floor === floor);
        if (currentRoom) {
            // Draw room background with texture
            ctx.fillStyle = '#151515';
            ctx.fillRect(currentRoom.x, currentRoom.y, currentRoom.width, currentRoom.height);
            
            // Draw room walls - thicker for big rooms
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(currentRoom.x, currentRoom.y, currentRoom.width, 30); // Top
            ctx.fillRect(currentRoom.x, currentRoom.y + currentRoom.height - 30, currentRoom.width, 30); // Bottom
            ctx.fillRect(currentRoom.x, currentRoom.y, 30, currentRoom.height); // Left
            ctx.fillRect(currentRoom.x + currentRoom.width - 30, currentRoom.y, 30, currentRoom.height); // Right
            
            // Draw wall details
            ctx.fillStyle = '#3a3a3a';
            // Vertical stripes on walls
            for (let i = 0; i < 5; i++) {
                const stripeX = currentRoom.x + 30 + i * 150;
                ctx.fillRect(stripeX, currentRoom.y, 5, 30);
                ctx.fillRect(stripeX, currentRoom.y + currentRoom.height - 30, 5, 30);
            }
            
            // Horizontal stripes on side walls
            for (let i = 0; i < 4; i++) {
                const stripeY = currentRoom.y + 30 + i * 140;
                ctx.fillRect(currentRoom.x, stripeY, 30, 5);
                ctx.fillRect(currentRoom.x + currentRoom.width - 30, stripeY, 30, 5);
            }
        }
        
        // Player movement
        if (!player.hidden) {
            if (joystickActive) {
                const moveX = joystickX / JOYSTICK_RADIUS;
                const moveY = joystickY / JOYSTICK_RADIUS;
                player.vx = moveX * player.speed;
                player.vy = moveY * player.speed;
            } else {
                player.vx *= 0.7; // More slippery for big rooms
                player.vy *= 0.7;
            }
            
            player.x += player.vx;
            player.y += player.vy;
            
            // Keep player in current room bounds
            if (currentRoom) {
                player.x = Math.max(currentRoom.x + 50, Math.min(currentRoom.x + currentRoom.width - 50, player.x));
                player.y = Math.max(currentRoom.y + 50, Math.min(currentRoom.y + currentRoom.height - 50, player.y));
            }
        }
        
        // Torch battery consumption
        if (torchOn && battery > 0) {
            battery -= 0.03; // Slower consumption
            updateBatteryDisplay();
            
            if (battery <= 0) {
                battery = 0;
                torchOn = false;
                document.getElementById('torch').style.opacity = 0;
                document.getElementById('flashlightBtn').style.background = 'rgba(40,40,0,0.6)';
                document.getElementById('flashlightBtn').style.borderColor = '#cc0';
            }
        }
        
        // Draw bullets
        for (let i = bullets.length-1; i >= 0; i--) {
            const b = bullets[i];
            const dx = b.tx - b.x;
            const dy = b.ty - b.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < 20 || b.life-- <= 0) {
                bullets.splice(i, 1);
                continue;
            }
            
            b.x += dx/dist * 25; // Faster bullets
            b.y += dy/dist * 25;
            
            ctx.strokeStyle = b.blood ? '#f00' : '#ff0';
            ctx.lineWidth = b.blood ? 4 : 6;
            ctx.beginPath();
            ctx.moveTo(b.x, b.y);
            ctx.lineTo(b.x + dx*0.2, b.y + dy*0.2);
            ctx.stroke();
            
            if (!b.blood) {
                ctx.shadowColor = '#ff0';
                ctx.shadowBlur = 15;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }
        
        // Draw player - bigger for big rooms
        const size = player.size;
        ctx.fillStyle = player.hidden ? '#444' : '#fff';
        ctx.fillRect(player.x - size/2, player.y - size, size, size*2);
        
        // Player details
        ctx.fillStyle = '#000';
        ctx.fillRect(player.x - size/3, player.y - size*0.7, size*0.66, size*0.4);
        
        // Arms
        ctx.fillStyle = player.hidden ? '#333' : '#c66';
        ctx.fillRect(player.x - size*0.9, player.y, size*0.7, size*1);
        ctx.fillRect(player.x + size*0.2, player.y, size*0.7, size*1);
        
        // Check if player is near a hiding spot
        nearHidingSpot = false;
        hidingSpots.forEach(spot => {
            const dist = Math.hypot(spot.x - player.x, spot.y - player.y);
            if (dist < 100 && !player.hidden) { // Bigger range for big rooms
                nearHidingSpot = true;
            }
        });
        
        // Update and draw ghosts - bigger and scarier
        for (const g of ghosts) {
            if (player.hidden) {
                if (g.wandering) {
                    const dx = g.wanderTargetX - g.x;
                    const dy = g.wanderTargetY - g.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < 50) {
                        g.wanderTargetX = g.x + (Math.random()-0.5)*400;
                        g.wanderTargetY = g.y + (Math.random()-0.5)*400;
                    } else {
                        g.x += dx/dist * (g.speed * 0.6);
                        g.y += dy/dist * (g.speed * 0.6);
                    }
                }
            } else {
                const dx = player.x - g.x;
                const dy = player.y - g.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 40) {
                    g.x += dx/dist * g.speed;
                    g.y += dy/dist * g.speed;
                }
            }
            
            // Keep ghosts in room
            if (currentRoom) {
                g.x = Math.max(currentRoom.x + 60, Math.min(currentRoom.x + currentRoom.width - 60, g.x));
                g.y = Math.max(currentRoom.y + 60, Math.min(currentRoom.y + currentRoom.height - 60, g.y));
            }
            
            // Draw ghost body - bigger and scarier
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(g.x, g.y, g.size, 0, Math.PI*2);
            ctx.fill();
            
            // Glow effect
            ctx.shadowColor = '#f00';
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Eyes - bigger
            ctx.fillStyle = '#400';
            ctx.beginPath();
            ctx.arc(g.x - 15, g.y - 12, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(g.x + 15, g.y - 12, 8, 0, Math.PI*2);
            ctx.fill();
            
            // Pupils
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(g.x - 15, g.y - 12, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(g.x + 15, g.y - 12, 4, 0, Math.PI*2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(g.x, g.y + 10, 15, 0.2, Math.PI - 0.2);
            ctx.stroke();
            
            // Damage player
            if (Math.hypot(g.x - player.x, g.y - player.y) < size + g.size && !player.hidden) {
                player.hp -= g.damage;
                document.getElementById('blood').style.opacity = 1;
                setTimeout(() => {
                    document.getElementById('blood').style.opacity = 0;
                }, 300);
                
                if (player.hp <= 0) {
                    player.hp = 0;
                    gameOver();
                }
                
                updateUI();
            }
        }
        
        // Draw hiding spots - bigger cabinets
        hidingSpots.forEach(s => {
            const isCurrentHidingSpot = player.hidingSpot && s.x === player.hidingSpot.x && s.y === player.hidingSpot.y;
            ctx.fillStyle = isCurrentHidingSpot ? '#002200' : '#333';
            ctx.fillRect(s.x - 60, s.y - 70, 120, 140);
            
            ctx.fillStyle = isCurrentHidingSpot ? '#113311' : '#555';
            ctx.fillRect(s.x - 48, s.y - 50, 48, 100);
            ctx.fillRect(s.x, s.y - 50, 48, 100);
            
            ctx.fillStyle = isCurrentHidingSpot ? '#0f0' : '#8f8';
            ctx.font = 'bold 16px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText("HIDE", s.x, s.y);
            
            // Draw handles
            ctx.fillStyle = '#aaa';
            ctx.fillRect(s.x - 40, s.y - 20, 10, 5);
            ctx.fillRect(s.x + 30, s.y - 20, 10, 5);
            ctx.fillRect(s.x - 40, s.y + 15, 10, 5);
            ctx.fillRect(s.x + 30, s.y + 15, 10, 5);
        });
        
        // Draw puzzles - bigger
        puzzles.forEach(p => {
            if (p.solved) return;
            
            let color = '#0ff';
            let puzzleText = "PUZZLE";
            
            if (p.special === 'rope') {
                color = '#ff8800';
                puzzleText = "ROPE";
            } else if (p.special === 'garage_key') {
                color = '#ff0';
                puzzleText = "GARAGE KEY";
            } else if (p.special === 'oil_can') {
                color = '#a0a0ff';
                puzzleText = "OIL CAN";
            } else if (p.special === 'duct_tape') {
                color = '#ffffa0';
                puzzleText = "DUCT TAPE";
            }
            
            ctx.fillStyle = color;
            ctx.fillRect(p.x - 60, p.y - 60, 120, 120);
            ctx.fillStyle = '#000';
            ctx.fillRect(p.x - 40, p.y - 40, 80, 80);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px "Courier New"';
            ctx.textAlign = 'center';
            
            ctx.fillText(puzzleText, p.x, p.y + 5);
            
            ctx.shadowColor = color;
            ctx.shadowBlur = 25;
            ctx.fillRect(p.x - 60, p.y - 60, 120, 120);
            ctx.shadowBlur = 0;
        });
        
        // Draw elevator - bigger
        if (elevator) {
            ctx.fillStyle = '#444';
            ctx.fillRect(elevator.x - 80, elevator.y - 80, 160, 160);
            ctx.fillStyle = '#0ff';
            ctx.font = 'bold 24px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText("LIFT", elevator.x, elevator.y - 20);
            ctx.fillText("A", elevator.x, elevator.y + 20);
            
            // Door lines
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(elevator.x - 40, elevator.y - 60);
            ctx.lineTo(elevator.x - 40, elevator.y + 60);
            ctx.moveTo(elevator.x + 40, elevator.y - 60);
            ctx.lineTo(elevator.x + 40, elevator.y + 60);
            ctx.stroke();
        }
        
        // Draw stairs - bigger
        if (stairsDown) {
            ctx.fillStyle = '#555';
            ctx.fillRect(stairsDown.x - 50, stairsDown.y - 60, 100, 120);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText("‚Üì", stairsDown.x, stairsDown.y + 10);
            ctx.font = 'bold 16px "Courier New"';
            ctx.fillText("TO " + stairsDown.to, stairsDown.x, stairsDown.y + 40);
        }
        
        if (stairsUp) {
            ctx.fillStyle = '#555';
            ctx.fillRect(stairsUp.x - 50, stairsUp.y - 60, 100, 120);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText("‚Üë", stairsUp.x, stairsUp.y + 10);
            ctx.font = 'bold 16px "Courier New"';
            ctx.fillText("TO " + stairsUp.to, stairsUp.x, stairsUp.y + 40);
        }
        
        // Draw car room - bigger
        if (carRoom) {
            // Garage floor
            ctx.fillStyle = '#333';
            ctx.fillRect(carRoom.x - 200, carRoom.y - 120, 400, 240);
            
            // Car - bigger
            ctx.fillStyle = player.carParts >= 10 ? '#00aa00' : '#aa0000';
            ctx.fillRect(carRoom.x - 120, carRoom.y - 60, 240, 120);
            ctx.fillStyle = '#000';
            ctx.fillRect(carRoom.x - 90, carRoom.y - 40, 180, 80);
            
            // Windows
            ctx.fillStyle = '#0af';
            ctx.fillRect(carRoom.x - 80, carRoom.y - 30, 60, 30);
            ctx.fillRect(carRoom.x + 20, carRoom.y - 30, 60, 30);
            
            // Wheels
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(carRoom.x - 100, carRoom.y + 40, 20, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(carRoom.x + 100, carRoom.y + 40, 20, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText("CAR", carRoom.x, carRoom.y - 90);
            ctx.fillText(`${player.carParts}/10 PARTS`, carRoom.x, carRoom.y + 90);
        }
        
        // Draw garage door - bigger
        if (garageDoor) {
            if (player.carParts >= 10) {
                ctx.fillStyle = '#008800';
                ctx.fillRect(garageDoor.x - 150, garageDoor.y - 100, 300, 200);
                ctx.fillStyle = '#000';
                ctx.fillRect(garageDoor.x - 100, garageDoor.y - 50, 200, 100);
                
                // Animated effect - more particles
                const time = Date.now() * 0.003;
                for (let i = 0; i < 15; i++) {
                    const a = time + i * 0.2;
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(garageDoor.x, garageDoor.y, 50 + i * 10, a, a + 1.5);
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 32px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText("GARAGE", garageDoor.x, garageDoor.y - 10);
                ctx.fillText("EXIT", garageDoor.x, garageDoor.y + 35);
            } else {
                ctx.fillStyle = '#400';
                ctx.fillRect(garageDoor.x - 150, garageDoor.y - 100, 300, 200);
                ctx.fillStyle = '#a22';
                ctx.font = 'bold 24px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText("LOCKED", garageDoor.x, garageDoor.y - 20);
                ctx.fillText(`${player.carParts}/10 PARTS`, garageDoor.x, garageDoor.y + 30);
            }
        }
        
        // Draw monster - scarier and bigger
        if (monster) {
            // Body
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(monster.x, monster.y, monster.size, 0, Math.PI*2);
            ctx.fill();
            
            // Spikes
            ctx.strokeStyle = '#600';
            ctx.lineWidth = 5;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const spikeLength = 30 + Math.sin(Date.now() * 0.005 + i) * 10;
                const x1 = monster.x + Math.cos(angle) * monster.size;
                const y1 = monster.y + Math.sin(angle) * monster.size;
                const x2 = monster.x + Math.cos(angle) * (monster.size + spikeLength);
                const y2 = monster.y + Math.sin(angle) * (monster.size + spikeLength);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Monster eyes - glowing
            ctx.fillStyle = '#300';
            ctx.beginPath();
            ctx.arc(monster.x - 35, monster.y - 30, 15, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(monster.x + 35, monster.y - 30, 15, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(monster.x - 35, monster.y - 30, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(monster.x + 35, monster.y - 30, 8, 0, Math.PI*2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(monster.x, monster.y + 20, 30, 0.3, Math.PI - 0.3);
            ctx.stroke();
            
            // Monster health bar - bigger
            ctx.fillStyle = '#333';
            ctx.fillRect(monster.x - 75, monster.y - monster.size - 40, 150, 15);
            ctx.fillStyle = '#f00';
            ctx.fillRect(monster.x - 75, monster.y - monster.size - 40, (monster.hp/1500)*150, 15);
            
            // Health text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText(`MONSTER: ${Math.floor(monster.hp)}/1500`, monster.x, monster.y - monster.size - 50);
            
            // Monster chases player
            if (!player.hidden) {
                const dx = player.x - monster.x;
                const dy = player.y - monster.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 80) {
                    monster.x += dx/dist * monster.speed;
                    monster.y += dy/dist * monster.speed;
                }
                
                // Monster damage
                if (dist < monster.size + player.size) {
                    player.hp -= 2;
                    if (player.hp <= 0) gameOver();
                    updateUI();
                }
            }
        }
        
        // Draw helicopter - bigger and better
        if (helicopter) {
            // Body
            ctx.fillStyle = '#666';
            ctx.fillRect(helicopter.x - 90, helicopter.y - 40, 180, 80);
            ctx.fillStyle = '#444';
            ctx.fillRect(helicopter.x - 70, helicopter.y - 30, 140, 60);
            
            // Windows
            ctx.fillStyle = '#0af';
            ctx.fillRect(helicopter.x - 60, helicopter.y - 20, 120, 40);
            
            // Rotor - animated
            const time = Date.now() * 0.008;
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 6;
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = time + i * (Math.PI * 2 / 4);
                const x1 = helicopter.x + Math.cos(angle) * 70;
                const y1 = helicopter.y - 60 + Math.sin(angle) * 70;
                const x2 = helicopter.x + Math.cos(angle + Math.PI) * 70;
                const y2 = helicopter.y - 60 + Math.sin(angle + Math.PI) * 70;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.stroke();
            
            // Landing gear
            ctx.fillStyle = '#333';
            ctx.fillRect(helicopter.x - 100, helicopter.y + 30, 20, 15);
            ctx.fillRect(helicopter.x + 80, helicopter.y + 30, 20, 15);
            
            ctx.fillStyle = '#0ff';
            ctx.font = 'bold 20px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText("HELICOPTER", helicopter.x, helicopter.y + 60);
        }
        
        // Show prompts
        const prompt = document.getElementById('prompt');
        prompt.style.display = 'none';
        
        // Position prompt above player
        const promptX = player.x - cameraX;
        const promptY = player.y - cameraY - 80;
        prompt.style.left = promptX + 'px';
        prompt.style.top = promptY + 'px';
        
        if (elevator && Math.hypot(elevator.x - player.x, elevator.y - player.y) < 120) {
            prompt.textContent = "A ‚Üí RANDOM FLOOR";
            prompt.style.display = 'block';
        } else if (stairsDown && Math.hypot(stairsDown.x - player.x, stairsDown.y - player.y) < 90) {
            prompt.textContent = "A ‚Üí GO DOWN";
            prompt.style.display = 'block';
        } else if (stairsUp && Math.hypot(stairsUp.x - player.x, stairsUp.y - player.y) < 90) {
            prompt.textContent = "A ‚Üí GO UP";
            prompt.style.display = 'block';
        } else if (nearHidingSpot && !player.hidden) {
            prompt.textContent = "A ‚Üí HIDE IN CABINET";
            prompt.style.display = 'block';
        } else if (player.hidden) {
            prompt.textContent = "A ‚Üí COME OUT";
            prompt.style.display = 'block';
        } else {
            // Check puzzle prompts
            for (let puzzle of puzzles) {
                if (!puzzle.solved && Math.hypot(puzzle.x - player.x, puzzle.y - player.y) < 100) {
                    let action = "SOLVE";
                    if (puzzle.special === 'rope') action = "TAKE ROPE";
                    else if (puzzle.special === 'garage_key') action = "TAKE KEY";
                    else if (puzzle.special === 'oil_can') action = "TAKE OIL CAN";
                    else if (puzzle.special === 'duct_tape') action = "TAKE DUCT TAPE";
                    
                    prompt.textContent = `A ‚Üí ${action}`;
                    prompt.style.display = 'block';
                    break;
                }
            }
        }
        
        if (carRoom && Math.hypot(carRoom.x - player.x, carRoom.y - player.y) < 160) {
            if (monster) {
                prompt.textContent = "A ‚Üí FIGHT MONSTER";
            } else if (!player.helicopterKey) {
                prompt.textContent = "A ‚Üí SEARCH CAR FOR KEY";
            } else {
                prompt.textContent = "A ‚Üí INSPECT CAR";
            }
            prompt.style.display = 'block';
        }
        
        if (garageDoor && player.carParts >= 10 && Math.hypot(garageDoor.x - player.x, garageDoor.y - player.y) < 140) {
            prompt.textContent = "A ‚Üí ESCAPE BY CAR!";
            prompt.style.display = 'block';
        }
        
        if (helicopter && Math.hypot(helicopter.x - player.x, helicopter.y - player.y) < 140) {
            prompt.textContent = "A ‚Üí ESCAPE BY HELICOPTER";
            prompt.style.display = 'block';
        }
        
        // Update minimap
        updateMiniMap();
        
    } catch (e) {
        console.error("Game loop error:", e);
    }
    
    if (gameRunning) {
        gameLoopId = requestAnimationFrame(gameLoop);
    }
}

// ============================================
// MODAL FUNCTIONS
// ============================================
function openPuzzle(puzzle) {
    let questions = [];
    
    // Different puzzle difficulties based on game mode
    switch(gameMode) {
        case 'easy':
            questions = [
                {q: "3+4=?", a: "7"},
                {q: "5+6=?", a: "11"},
                {q: "9-3=?", a: "6"},
                {q: "2√ó5=?", a: "10"},
                {q: "8√∑2=?", a: "4"},
                {q: "7+8=?", a: "15"},
                {q: "12-5=?", a: "7"},
                {q: "3√ó4=?", a: "12"},
                {q: "6+9=?", a: "15"},
                {q: "14-7=?", a: "7"}
            ];
            break;
            
        case 'normal':
            questions = [
                {q: "7√ó9=?", a: "63"},
                {q: "15-6=?", a: "9"},
                {q: "25√∑5=?", a: "5"},
                {q: "12+18=?", a: "30"},
                {q: "8√ó8=?", a: "64"},
                {q: "3√ó7=?", a: "21"},
                {q: "14+9=?", a: "23"},
                {q: "36√∑6=?", a: "6"},
                {q: "11√ó5=?", a: "55"},
                {q: "45-18=?", a: "27"}
            ];
            break;
            
        case 'hard':
            questions = [
                {q: "13√ó7=?", a: "91"},
                {q: "48√∑6=?", a: "8"},
                {q: "17+25=?", a: "42"},
                {q: "63-28=?", a: "35"},
                {q: "9√ó12=?", a: "108"},
                {q: "81√∑9=?", a: "9"},
                {q: "34+47=?", a: "81"},
                {q: "72-36=?", a: "36"},
                {q: "14√ó8=?", a: "112"},
                {q: "96√∑8=?", a: "12"}
            ];
            break;
            
        case 'impossible':
            questions = [
                {q: "17√ó13=?", a: "221"},
                {q: "144√∑12=?", a: "12"},
                {q: "89+67=?", a: "156"},
                {q: "125-78=?", a: "47"},
                {q: "15√ó16=?", a: "240"},
                {q: "196√∑14=?", a: "14"},
                {q: "123+89=?", a: "212"},
                {q: "200-123=?", a: "77"},
                {q: "18√ó14=?", a: "252"},
                {q: "225√∑15=?", a: "15"}
            ];
            break;
    }
    
    const q = questions[Math.floor(Math.random() * questions.length)];
    document.getElementById('puzzleQuestion').textContent = q.q;
    document.getElementById('puzzleAnswer').value = '';
    document.getElementById('puzzleModal').style.display = 'flex';
    document.getElementById('puzzleAnswer').focus();
    window.currentPuzzle = puzzle;
    window.currentAnswer = q.a;
}

function closePuzzle() {
    document.getElementById('puzzleModal').style.display = 'none';
}

document.getElementById('submitPuzzle').onclick = () => {
    const answer = document.getElementById('puzzleAnswer').value.trim();
    const puzzle = window.currentPuzzle;
    
    if (answer === window.currentAnswer) {
        puzzle.solved = true;
        puzzlesSolved++;
        closePuzzle();
        
        // Give rewards
        if (puzzle.special === 'rope') {
            showAlert("üß∂ Found Rope! Can climb between floors faster");
            player.keys++;
        } else if (puzzle.special === 'garage_key') {
            showAlert("üîë Found Garage Key!");
            player.keys++;
        } else if (puzzle.special === 'oil_can') {
            player.oilCan = true;
            showAlert("üõ¢Ô∏è Found Oil Can for helicopter!");
            updateInventory();
        } else if (puzzle.special === 'duct_tape') {
            player.ductTape = true;
            showAlert("üéûÔ∏è Found Duct Tape for helicopter!");
            updateInventory();
        } else {
            // Normal puzzle rewards
            if (puzzlesSolved <= 10) {
                // First 10 puzzles give car parts
                inventory.car_part++;
                player.carParts++;
                showAlert("üîß Car Part Found! (" + player.carParts + "/10)");
            } else {
                // Next 10 puzzles give health, battery, ammo
                const rewardType = ['health_pack', 'battery_pack', 'ammo'][Math.floor(Math.random() * 3)];
                inventory[rewardType]++;
                
                if (rewardType === 'health_pack') showAlert("‚ù§Ô∏è Health Pack Found!");
                else if (rewardType === 'battery_pack') showAlert("üîã Battery Pack Found!");
                else showAlert("üî´ Ammo Found!");
            }
        }
        
        updateUI();
        updateInventory();
    } else {
        showAlert("‚ùå WRONG ANSWER!");
    }
};

function showAlert(msg) {
    const alert = document.createElement('div');
    alert.style.cssText = `
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(100, 0, 0, 0.9);
        color: #ffd0d0;
        padding: 12px 20px;
        border-radius: 10px;
        border: 3px solid #c00;
        font-size: 1.1rem;
        z-index: 100000;
        text-align: center;
        max-width: 85%;
        box-shadow: 0 0 25px #800;
        font-family: 'Courier New', monospace;
        backdrop-filter: blur(10px);
    `;
    alert.textContent = msg;
    document.body.appendChild(alert);
    setTimeout(() => alert.remove(), 2000);
}

function changeFloor(to) {
    // Fade effect
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
    
    setTimeout(() => {
        initFloor(to);
    }, 400);
}

function gameOver() {
    gameRunning = false;
    showScreen('gameoverScreen');
    
    const scare = document.getElementById('scareSound');
    scare.currentTime = 0;
    scare.play().catch(e => console.log("Scare sound error"));
    
    document.getElementById('bgm').pause();
}

function winGame(method) {
    gameRunning = false;
    const winMessage = document.getElementById('winMessage');
    
    if (method === 'car') {
        winMessage.textContent = "You repaired the car and escaped! Freedom at last...";
        winMessage.style.color = "#0f0";
    } else {
        winMessage.textContent = "You escaped by helicopter! You made it out alive!";
        winMessage.style.color = "#0ff";
    }
    
    showScreen('winScreen');
    document.getElementById('bgm').pause();
}

// ============================================
// UTILITY FUNCTIONS
// ============================================
function exitApp() {
    if (navigator.app && navigator.app.exitApp) {
        navigator.app.exitApp();
    } else if (navigator.device && navigator.device.exitApp) {
        navigator.device.exitApp();
    } else {
        if (window.history.length > 1) {
            window.history.back();
        } else {
            window.close();
            setTimeout(() => {
                window.location.href = 'about:blank';
            }, 1000);
            alert("Tap back button again to exit");
        }
    }
}

// ============================================
// INITIALIZATION
// ============================================
window.addEventListener('resize', () => {
    VIEWPORT_WIDTH = window.innerWidth;
    VIEWPORT_HEIGHT = window.innerHeight;
});

document.addEventListener('touchmove', function(e) {
    if (e.target === canvas || 
        e.target === joystickArea || 
        e.target === joystick || 
        e.target.closest('#controls')) {
        e.preventDefault();
    }
}, { passive: false });

document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    return false;
});

document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' || e.key === 'Backspace') {
        e.preventDefault();
        if (document.getElementById('gameScreen').style.display === 'flex') {
            showScreen('startScreen');
        } else {
            exitApp();
        }
    }
});

// Initialize
showScreen('startScreen');
console.log("CURSED APARTMENT - BORO ROOM VERSION Loaded");
</script>
</body>
</html>